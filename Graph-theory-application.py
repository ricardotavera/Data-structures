# -*- coding: utf-8 -*-
"""Copy of MisMandados.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EuOic5CjK7p_j1wvmdN8mgwn0PPGnCkS
"""

# Commented out IPython magic to ensure Python compatibility.
# Importando algunas librerías que utilizaremos

# Networkx para grafos
import networkx as nx

# Pandas
import pandas as pd

# Mostrar imágenes
from IPython.display import HTML

# Mathplotlib
import matplotlib.pyplot as plt



# %matplotlib inline
plt.rcParams['figure.figsize'] = (20.0, 10.0)

from google.colab import files
files.upload()

datos = pd.read_csv('datasetSocorro.csv')
print(datos)

"""# New section"""

Grafo = nx.Graph()
for row in datos.iterrows():
  Grafo.add_edge(row[1]["NODO1"],
             row[1]["NODO2"],
             distancia=row[1]["DISTANCIAS"])
Grafo.nodes(data=True)

nx.draw_kamada_kawai(Grafo,
                 node_color="lightblue",
                 edge_color="black",
                 font_size=10,
                 width=2, with_labels=True, node_size=700,
)

def plot_shortest_path(path):
    print(path)
    positions = nx.kamada_kawai_layout(Grafo)
    
    nx.draw(Grafo, pos=positions,
                node_color="lightblue",
                 edge_color="black",
                 font_size=10,
                 width=2, with_labels=True, node_size=900,
           )
    
    short_path=nx.Graph()
    for i in range(len(path)-1):
        short_path.add_edge(path[i], path[i+1])
    
    nx.draw(short_path, pos=positions,
                node_color='green',
                edge_color='green',
                font_size=10,
                width=3, with_labels=True, node_size=850
           )
    plt.show()

from google.colab import files
from IPython.display import Image
file1 = files.upload()

Image("Socorro Map.jpeg", width=1000)

rutaOptima1 = list(nx.astar_path(Grafo, ("A1"), ("J6"), weight="distancia"))
rutaOptima2 = list(nx.astar_path(Grafo, ("J6"), ("O7"), weight="distancia"))
rutaOptima1 = rutaOptima1 + rutaOptima2
rutaOptima2 = list(nx.astar_path(Grafo, ("O7"), ("V5"), weight="distancia"))
rutaOptima1 = rutaOptima1 + rutaOptima2
rutaOptima2 = list(nx.astar_path(Grafo, ("V5"), ("A1"), weight="distancia"))
rutaOptima1 = rutaOptima1 + rutaOptima2

plot_shortest_path(rutaOptima1)

try:
   r= nx.astar_path_length(Grafo, "P1", "S1",weight="distancia")
   print(r)
except nx.NetworkXNoPath:
    print ('No path')

"""Algoritmo A estrella (AStar)

Definicion proporcionada: Para entender el algoritmo A*, debemos pensar en el resultado de una función, con la suma entre el coste del nodo y la heurística que es calculado, desde el nodo actual hasta el nodo destino, lo podemos expresar como f(n) = g(n) + h'(n).

Donde f(n) es el resultado o peso del nodo a evaluar.
g(n) sería el coste de la arista
h'(n) la heurística que hace una estimación del nodo actual hasta el destino 
https://www.apascualco.com/
"""

tree = {'S': [['A', 1], ['B', 5], ['C', 8]],                   #Información guía en: https://www.youtube.com/watch?v=birig65AP2A&ab_channel=NianLi
        'A': [['S', 1], ['D', 3], ['E', 7], ['G', 9]],
        'B': [['S', 5], ['G', 4]],
        'C': [['S', 8], ['G', 5]],
        'D': [['A', 3]],
        'E': [['A', 7]]}

tree2 = {'S': [['A', 1], ['B', 2]],
         'A': [['S', 1]],
         'B': [['S', 2], ['C', 3], ['D', 4]],
         'C': [['B', 2], ['E', 5], ['F', 6]],
         'D': [['B', 4], ['G', 7]],
         'E': [['C', 5]],
         'F': [['C', 6]]
         }
  


heuristic = {'S': 8, 'A': 8, 'B': 4, 'C': 3, 'D': 5000, 'E': 5000, 'G': 0}
heuristic2 = {'S': 0, 'A': 5000, 'B': 2, 'C': 3, 'D': 4, 'E': 5000, 'F': 5000, 'G': 0}

cost = {'S': 0}             # total cost for nodes visited


def AStarSearch():
    global tree, heuristic
    closed = []             # closed nodes
    opened = [['S', 8]]     # opened nodes

    '''find the visited nodes'''
    while True:
        fn = [i[1] for i in opened]     # fn = f(n) = g(n) + h(n)
        chosen_index = fn.index(min(fn))
        node = opened[chosen_index][0]  # current node
        closed.append(opened[chosen_index])
        del opened[chosen_index]
        if closed[-1][0] == 'G':        # break the loop if node G has been found
            break
        for item in tree[node]:
            if item[0] in [closed_item[0] for closed_item in closed]:
                continue
            cost.update({item[0]: cost[node] + item[1]})            # add nodes to cost dictionary
            fn_node = cost[node] + heuristic[item[0]] + item[1]     # calculate f(n) of current node
            temp = [item[0], fn_node]
            opened.append(temp)                                     # store f(n) of current node in array opened

    '''find optimal sequence'''
    trace_node = 'G'                        # correct optimal tracing node, initialize as node G
    optimal_sequence = ['G']                # optimal node sequence
    for i in range(len(closed)-2, -1, -1):
        check_node = closed[i][0]           # current node
        if trace_node in [children[0] for children in tree[check_node]]:
            children_costs = [temp[1] for temp in tree[check_node]]
            children_nodes = [temp[0] for temp in tree[check_node]]

            '''check whether h(s) + g(s) = f(s). If so, append current node to optimal sequence
            change the correct optimal tracing node to current node'''
            if cost[check_node] + children_costs[children_nodes.index(trace_node)] == cost[trace_node]:
                optimal_sequence.append(check_node)
                trace_node = check_node
    optimal_sequence.reverse()              # reverse the optimal sequence

    return closed, optimal_sequence


if __name__ == '__main__':
    visited_nodes, optimal_nodes = AStarSearch()
    print('visited nodes: ' + str(visited_nodes))
    print('optimal nodes sequence: ' + str(optimal_nodes))

"""La cantidad de posibilidades que hay para hallar un recorrido óptimo teniendo a A como nodo de partidad y al conjunto S = {B,C,D,E,F,...} si se tiene que |S| = n entonces cantidad de caminos que empiezab en A y pasan por todos los nodos de S = n!"""

# Funcion de recorrido óptimo
from itertools import permutations  
  
def recorridoOptimo( origen, paradas):
    distanciaOptima = 100000
    rutaOptima = list() #nx.astar_path(Grafo, (origen), (origen), weight="distancia")
    rutalocal = list()
    distancialocal =  0
    posiblesrecorridos = list(permutations(paradas))
    for i in list(posiblesrecorridos):
       
       rutalocal = list(i)
       distancialocal = nx.astar_path_length(Grafo, origen, rutalocal[0], weight="distancia")
       
       
       for j in range(len(rutalocal)-1):
        
         
         distancialocal = distancialocal + nx.astar_path_length(Grafo, rutalocal[j], rutalocal[j+1], weight="distancia")
         
         if distancialocal > distanciaOptima:
           break
        
       if distancialocal < distanciaOptima:
        rutaOptima = rutalocal
        distanciaOptima = distancialocal 
      
    recorrido = nx.astar_path(Grafo, origen, rutaOptima[0], weight="distancia" ) 
    for x in range(len(rutaOptima)-1):
      recorrido = recorrido + list(nx.astar_path(Grafo, rutaOptima[x],rutaOptima[x+1], weight="distancia"))
    
    
    print("Ruta óptima encontrada ||> : %s" % (origen))
    plot_shortest_path(recorrido)
    return recorrido, distanciaOptima

recorridoOptimo('A1', (['O7','Z5','C2','M4','E6']))





nx.draw_kamada_kawai(Grafo, node_size=50, width=0.5, with_labels=False)  # Dibujar el grafo G con una interfaz particular
plt.axis("equal")  # Redimensionar los ejes a longitudes iguales
plt.show()  # Mostrar el grado d-regular por pantalla